[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/msi/Documents/GitHub/Hangman-Scala/build.sbt","languageId":"scala","version":1,"text":"name := \"hangman\"\r\n \r\nversion := \"1.0\"\r\n \r\nscalaVersion := \"2.12.11\"\r\n \r\nfork := true\r\n\r\n\r\n// https://mvnrepository.com/artifact/org.scalafx/scalafx\r\nlibraryDependencies += \"org.scalafx\" %% \"scalafx\" % \"18.0.1-R27\"\r\n\r\n// https://mvnrepository.com/artifact/org.scalafx/scalafxml-core-sfx8\r\nlibraryDependencies += \"org.scalafx\" %% \"scalafxml-core-sfx8\" % \"0.5\"\r\n\r\n\r\naddCompilerPlugin(\"org.scalamacros\" % \"paradise\" % \"2.1.1\" cross CrossVersion.full) \r\n\r\n\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/msi/Documents/GitHub/Hangman-Scala/src/main/scala/ch/makery/hangman/view/HangmanGameOverController.scala","languageId":"scala","version":1,"text":"package ch.makery.hangman.view\r\n\r\nimport ch.makery.hangman.MainApp\r\nimport scalafxml.core.macros.sfxml\r\nimport scalafx.Includes._\r\nimport scalafx.event.ActionEvent\r\nimport scalafx.scene.control.Alert.AlertType\r\nimport scala.util.{Failure, Success}\r\nimport scalafx.scene.image.{Image, ImageView}\r\nimport scalafx.scene.control.{Button}\r\nimport scalafx.scene.text.Text\r\nimport scalafx.stage.Stage\r\n\r\n@sfxml\r\n// Controller for HangGameOver.fxml\r\nclass HangmanGameOverController(\r\n    gameoverBG: ImageView,\r\n    homeButton: Button,\r\n    scoreText: Text,\r\n    answerText: Text\r\n) {\r\n\r\n    // Set to display total score value in Text object \r\n    var scoreDisplay = scoreText\r\n    var answerDisplay = answerText\r\n\r\n    var dialogStage: Stage = null\r\n\r\n    // Set background\r\n    gameoverBG.image = new Image(\"file:resources/images/dead.jpg\")\r\n\r\n    // Function to return to the main menu when player click the home button \r\n    def goHome(action : ActionEvent): Unit = {\r\n        MainApp.showHomeScreen()\r\n        dialogStage.close()\r\n    }\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/msi/Documents/GitHub/Hangman-Scala/src/main/scala/ch/makery/hangman/view/HangmanRuleController.scala","languageId":"scala","version":1,"text":"package ch.makery.hangman.view\r\n\r\n// Import libraries \r\nimport ch.makery.hangman.MainApp\r\nimport scalafxml.core.macros.sfxml\r\nimport scalafx.Includes._\r\nimport scalafx.event.ActionEvent\r\nimport scalafx.scene.control.Alert.AlertType\r\nimport scala.util.{Failure, Success}\r\nimport scalafx.scene.image.{Image, ImageView}\r\nimport scalafx.scene.control.{Button}\r\nimport scalafx.scene.text.Text\r\nimport scalafx.stage.Stage\r\n\r\n@sfxml\r\n// Controller for  HangmanRule.fxml\r\nclass HangmanRuleController() {\r\n\r\n    // A function to go back to the main menu when player click back button \r\n    def goHome(action : ActionEvent): Unit = {\r\n        MainApp.showHomeScreen()\r\n    }\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/msi/Documents/GitHub/Hangman-Scala/src/main/scala/ch/makery/hangman/view/HomeScreenController.scala","languageId":"scala","version":1,"text":"package ch.makery.hangman.view\r\n\r\n// Import libraries \r\nimport ch.makery.hangman.MainApp\r\nimport scalafxml.core.macros.sfxml\r\nimport scalafx.Includes._\r\nimport scalafx.event.ActionEvent\r\nimport scalafx.scene.control.Alert.AlertType\r\nimport scala.util.{Failure, Success}\r\nimport scalafx.scene.image.{Image, ImageView}\r\nimport scalafx.scene.media.{Media, MediaPlayer}\r\n\r\n@sfxml\r\n// Controller for HomeScreen.fxml\r\nclass HomeScreenController() {\r\n\r\n    // Start the game when player click play button \r\n    def startGame(action : ActionEvent): Unit = {\r\n        MainApp.showGame()\r\n    }\r\n\r\n    // Terminate the program when play click the quit button \r\n    def endGame(action: ActionEvent): Unit = {\r\n        System.exit(0)\r\n    }\r\n\r\n    // Execute a new scene to display the game's instruction when player click the how to play button \r\n    def showRule(action: ActionEvent): Unit = {\r\n        MainApp.showRule()\r\n    }\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\Users\msi\Documents\GitHub\Hangman-Scala\target\scala-2.12\zinc\inc_compile_2.12.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Jul 15, 2022 6:20:42 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/msi/Documents/GitHub/Hangman-Scala/src/main/scala/ch/makery/hangman/MainApp.scala","languageId":"scala","version":1,"text":"package ch.makery.hangman\r\n\r\n// Import libraries \r\nimport scalafx.Includes._\r\nimport scalafx.application.JFXApp\r\nimport scalafx.application.JFXApp.PrimaryStage\r\nimport javafx.{scene => jfxs}\r\nimport scalafxml.core.{NoDependencyResolver, FXMLView, FXMLLoader}\r\nimport scalafx.scene.Scene\r\nimport scalafx.stage.{ Stage, Modality, StageStyle }\r\nimport ch.makery.hangman.view.HangmanWinController\r\nimport ch.makery.hangman.view.HangmanGameOverController\r\nimport ch.makery.hangman.view.HangmanGameController\r\nimport scalafx.scene.image._\r\n\r\n// Main app object \r\nobject MainApp extends JFXApp{\r\n\r\n    // score: an Int variable to store game score\r\n    var score = 0\r\n\r\n    // Load the resources from the main fxml file \r\n    val rootResource = getClass.getResource(\"view/RootLayout.fxml\")\r\n    val loader = new FXMLLoader(rootResource, NoDependencyResolver)\r\n    loader.load();\r\n    val roots = loader.getRoot[jfxs.layout.BorderPane]\r\n\r\n    // Create primary stage as the main window of the program\r\n    stage = new PrimaryStage{\r\n        title = \"Hangman\"\r\n        icons += new Image(\"file:resources/images/hangman.png\")\r\n        scene = new Scene{\r\n            root = roots\r\n        }\r\n    }\r\n\r\n    // Disable stage resize \r\n    MainApp.stage.setResizable(false)\r\n\r\n    // Function to display home screen on stage \r\n    def showHomeScreen(): Unit = {\r\n        val resource = getClass.getResource(\"view/HomeScreen.fxml\")\r\n        val loader = new FXMLLoader(resource, NoDependencyResolver)\r\n        loader.load()\r\n        val roots = loader.getRoot[jfxs.layout.AnchorPane]\r\n        this.roots.setCenter(roots)\r\n    }\r\n\r\n    // Function to display instructions on stage \r\n    def showRule(): Unit = {\r\n        val resource = getClass.getResource(\"view/HangmanRule.fxml\")\r\n        val loader = new FXMLLoader(resource, NoDependencyResolver)\r\n        loader.load()\r\n        val roots = loader.getRoot[jfxs.layout.AnchorPane]\r\n        this.roots.setCenter(roots)\r\n    }\r\n\r\n    // Function to start game \r\n    def showGame(): Unit = {\r\n        val resource = getClass.getResource(\"view/HangmanGame.fxml\")\r\n        val loader = new FXMLLoader(resource, NoDependencyResolver)\r\n        loader.load()\r\n        val roots = loader.getRoot[jfxs.layout.AnchorPane]\r\n        this.roots.setCenter(roots)\r\n    }\r\n\r\n    // Open up a new dialog to congratulate user for winning  \r\n    def showWonGame(): Unit = {\r\n        val resource = getClass.getResource(\"view/HangmanWin.fxml\")\r\n        val loader = new FXMLLoader(resource, NoDependencyResolver)\r\n        loader.load()\r\n        val control = loader.getController[HangmanWinController#Controller]\r\n        val roots2 = loader.getRoot[jfxs.layout.AnchorPane]\r\n        var dialog = new Stage() {\r\n            title = \"Hangman\"\r\n            icons += new Image(\"file:resources/images/hangman.png\")\r\n            initModality(Modality.APPLICATION_MODAL)\r\n            initOwner(stage)\r\n            scene = new Scene {\r\n                root = roots2\r\n            }\r\n        }\r\n        // Updates the score when player guessed a word correctly \r\n        score += 1 \r\n        // Update the text in the scene \r\n        control.scoreDisplay.setText(score.toString)\r\n        control.dialogStage = dialog\r\n        dialog.setResizable(false)\r\n        // Disable minimise, maximise, and close button \r\n        dialog.initStyle(StageStyle.UNDECORATED)\r\n        // Dialog needs to be interacted before interacting with the main window \r\n        dialog.showAndWait()\r\n    }\r\n\r\n    // Open up a new dialog when player lost \r\n    // Argument: answer as string variable, to display the answer in the dialog\r\n    def showGameOver(answer: String): Unit = {\r\n        \r\n        val resource = getClass.getResource(\"view/HangmanGameOver.fxml\")\r\n        val loader = new FXMLLoader(resource, NoDependencyResolver)\r\n        loader.load()\r\n        val control = loader.getController[HangmanGameOverController#Controller]\r\n        val roots3 = loader.getRoot[jfxs.layout.AnchorPane]\r\n\r\n        var dialog2 = new Stage() {\r\n            title = \"Hangman\"\r\n            icons += new Image(\"file:resources/images/hangman.png\")\r\n            initModality(Modality.APPLICATION_MODAL)\r\n            initOwner(stage)\r\n            scene = new Scene {\r\n                root = roots3\r\n            }\r\n        }\r\n        // Update text on scene to display score and answer \r\n        control.scoreDisplay.setText(score.toString)\r\n        control.answerDisplay.setText(answer)\r\n        control.dialogStage = dialog2\r\n        // disable minimise, maximise, and close button \r\n        dialog2.initStyle(StageStyle.UNDECORATED)\r\n        dialog2.setResizable(false)\r\n        // Dialog needs to be interacted before interacting with the main window \r\n        dialog2.showAndWait()\r\n    }\r\n\r\n    // Display the home screen when the program runs \r\n    showHomeScreen()\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/msi/Documents/GitHub/Hangman-Scala/src/main/scala/ch/makery/hangman/view/HangmanWinController.scala","languageId":"scala","version":1,"text":"package ch.makery.hangman.view\r\n\r\n// Import libraries \r\nimport ch.makery.hangman.MainApp\r\nimport scalafxml.core.macros.sfxml\r\nimport scalafx.Includes._\r\nimport scalafx.event.ActionEvent\r\nimport scalafx.scene.control.Alert.AlertType\r\nimport scala.util.{Failure, Success}\r\nimport scalafx.scene.image.{Image, ImageView}\r\nimport scalafx.scene.control.{Button}\r\nimport scalafx.scene.text.Text\r\nimport scalafx.stage.Stage\r\n\r\n@sfxml\r\n// Controller for HangmanWin.fxml\r\nclass HangmanWinController(\r\n    wingameBG: ImageView,\r\n    nextButton: Button,\r\n    scoreText: Text\r\n) {\r\n\r\n    // Text object; used to change text value \r\n    var scoreDisplay = scoreText\r\n    var dialogStage: Stage = null\r\n\r\n    // Set background image \r\n    wingameBG.image = new Image(\"file:resources/images/Win.jpg\")\r\n\r\n    // Game will go to the next level when user click next button\r\n    def goNext(action : ActionEvent): Unit = { \r\n        MainApp.showGame()\r\n        dialogStage.close()\r\n    }\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/msi/Documents/GitHub/Hangman-Scala/src/main/scala/ch/makery/hangman/view/HangmanGameController.scala","languageId":"scala","version":1,"text":"package ch.makery.hangman.view\r\n\r\nimport ch.makery.hangman.MainApp\r\nimport ch.makery.hangman.model.Word\r\nimport scalafxml.core.macros.sfxml\r\nimport scalafx.Includes._\r\nimport scalafx.event.ActionEvent\r\nimport scalafx.scene.control.Alert.AlertType\r\nimport scala.util.{Failure, Success}\r\nimport scalafx.scene.image.{Image, ImageView}\r\nimport scalafx.scene.control.{Button}\r\nimport scalafx.scene.text.Text\r\n\r\n@sfxml\r\n// Controller for HangmanGame.fxml\r\nclass HangmanGameController(\r\n    hangmanImage: ImageView,\r\n    qKey: Button,\r\n    wKey: Button,\r\n    eKey: Button,\r\n    rKey: Button,\r\n    tKey: Button,\r\n    yKey: Button,\r\n    uKey: Button,\r\n    iKey: Button,\r\n    oKey: Button,\r\n    pKey: Button,\r\n    aKey: Button,\r\n    sKey: Button,\r\n    dKey: Button,\r\n    fKey: Button,\r\n    gKey: Button,\r\n    hKey: Button,\r\n    jKey: Button,\r\n    kKey: Button,\r\n    lKey: Button,\r\n    zKey: Button,\r\n    xKey: Button,\r\n    cKey: Button,\r\n    vKey: Button,\r\n    bKey: Button,\r\n    nKey: Button,\r\n    mKey: Button,\r\n    hangmanText: Text\r\n    ) {\r\n\r\n    // Assign variables and instance that will be used for the game  \r\n    var hangmanWord = new Word(\"src/main/randomWords.txt\")\r\n    var wordList: List[String] = null\r\n    var word: String = null\r\n    var charList: List[Char] = null\r\n    var wordSize: Int = 0\r\n    var placeholder: List[Char] = null\r\n    var text: String = null\r\n    var counter: Int = 0\r\n    var remain: Int = 0\r\n\r\n    // A function to generate random words from the text file \r\n    def generateWord(): Unit = {\r\n        wordList = hangmanWord.wordList()\r\n        word = hangmanWord.selectWord(wordList)\r\n        charList = hangmanWord.wordSplit(word)\r\n        wordSize = word.length()\r\n        placeholder = hangmanWord.generatePlaceholder(wordSize)\r\n    }\r\n\r\n    // A function to check the input for correct answer of the letter\r\n   def checkAns(input: Char): Boolean = {\r\n    // If returns true, loop through the word to see if letter exists in the word \r\n    // Will update the blank spaces with the correct letter \r\n    if (hangmanWord.checkWord(input)) {\r\n        for (i <- 0 to wordSize-1) {\r\n            if (charList(i) == input) {\r\n                remain -= 1\r\n                placeholder = placeholder.updated(i, input)\r\n            }\r\n        }\r\n        text = placeholder.mkString(\" \")\r\n        hangmanText.setText(text)\r\n        // If the word is guessed correctly, will display a dialog to congrulate the player \r\n        if (remain == 0) { \r\n            MainApp.showWonGame()\r\n        }\r\n        return true\r\n    }\r\n    // If the letter is guessed incorrectly, a body piece of hangman will appear on the screen\r\n    else {\r\n        if (counter == 0) {\r\n            hangmanImage.setVisible(true)\r\n        }\r\n        else {\r\n            hangmanImage.image = new Image(imageList(counter))\r\n            hangmanImage.setVisible(true)\r\n        }\r\n        // Update the counter\r\n        counter += 1\r\n        // If hangman is fully shown, game will terminate and display a game over dialog \r\n        if (counter == 5) {\r\n            MainApp.showGameOver(word)\r\n        }\r\n        return false\r\n    }\r\n   }\r\n\r\n   // Calling function to generate random word \r\n   generateWord()\r\n\r\n   // Setting blanks according to the number of letters in the word \r\n   text = placeholder.mkString(\" \")\r\n   hangmanText.setText(text)\r\n\r\n   // Counter to count the number of incorrect guesses \r\n   counter = 0\r\n   // remain; a variable to count the number of letters left to guess correctly \r\n   remain = wordSize\r\n   // A list that stores the file paths of the images of hangman \r\n   private val imageList = List(\"file:resources/images/wrong1.png\", \"file:resources/images/wrong2.png\", \"file:resources/images/wrong3.png\", \"file:resources/images/wrong4.png\", \"file:resources/images/wrong5.png\")\r\n   // Set image to imageView according to the counter \r\n   hangmanImage.image = new Image(imageList(counter))\r\n   // Set image to not be visible when the game starts \r\n   hangmanImage.setVisible(false)\r\n\r\n   // Functions for every keys in the game \r\n   // If letter is guessed correctly, will replace the blank with the correct letter o nthe screen\r\n   // Button will not be visible after button is pressed and guessed correctly \r\n   // Otherwise, will display a body piece of hangman \r\n   qKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('Q')) {\r\n        qKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   wKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('W')) {\r\n        wKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   eKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('E')) {\r\n        eKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   rKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('R')) {\r\n        rKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   tKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('T')) {\r\n        tKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   yKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('Y')) {\r\n        yKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   uKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('U')) {\r\n        uKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   iKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('I')) {\r\n        iKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   oKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('O')) {\r\n        oKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   pKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('P')) {\r\n        pKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   aKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('A')) {\r\n        aKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   sKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('S')) {\r\n        sKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   dKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('D')) {\r\n        dKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   fKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('F')) {\r\n        fKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   gKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('G')) {\r\n        gKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   hKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('H')) {\r\n        hKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   jKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('J')) {\r\n        jKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   kKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('K')) {\r\n        kKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   lKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('L')) {\r\n        lKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   zKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('Z')) {\r\n        zKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   xKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('X')) {\r\n        xKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   cKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('C')) {\r\n        cKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   vKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('V')) {\r\n        vKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   bKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('B')) {\r\n        bKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   nKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('N')) {\r\n        nKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   mKey.onAction = (e: ActionEvent) => {\r\n    if (checkAns('M')) {\r\n        mKey.setVisible(false)\r\n    }\r\n   }\r\n\r\n   // Button in menubar \r\n   // Button to go back to the main menu\r\n   def goHome(action: ActionEvent): Unit = {\r\n    MainApp.showHomeScreen()\r\n   }\r\n   // Button to terminate the program and exit the game \r\n   def exitGame(action: ActionEvent): Unit = {\r\n    System.exit(0)\r\n   }\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/msi/Documents/GitHub/Hangman-Scala/src/main/scala/ch/makery/hangman/model/Word.scala","languageId":"scala","version":1,"text":"package ch.makery.hangman.model \r\n\r\n// Import random library \r\nimport scala.util.Random\r\n\r\nclass Word(file: String){\r\n\r\n    var filename = file\r\n    var word:String = \"\"\r\n\r\n    // Function to select a word from the list, return as string \r\n    def selectWord(wordList: List[String]): String = {\r\n        word = wordList(scala.util.Random.nextInt(wordList.length))\r\n        return word\r\n    }\r\n\r\n    // Place every word in the txt file to a list, return as list of strings\r\n    def wordList(): List[String] = {\r\n        val source = io.Source.fromFile(filename)\r\n        val words : List[String] = source.getLines.toList\r\n        source.close()\r\n        return words\r\n    }\r\n\r\n    // Split the word into a list of characters, return as list of characters\r\n    def wordSplit(word: String): List[Char] = {\r\n        return word.toList\r\n    }\r\n\r\n    // Generate the blanks based on the number of letters in a word, return as list of characters\r\n    def generatePlaceholder(wordSize: Int): List[Char] = {\r\n        return wordSplit(\"_\" * wordSize)\r\n    }\r\n\r\n    // Function to check if the letter is guessed correctly, return as boolean \r\n    def checkWord(input: Char): Boolean = {\r\n        if (word.contains(input)) {\r\n            return true\r\n        }\r\n        else {\r\n            return false\r\n        }\r\n    }\r\n}"}})[0m
